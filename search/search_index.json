{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"CloudFront Tenant Operator","text":"<p>A Kubernetes operator for managing CloudFront Distribution Tenants -- the AWS CloudFront multi-tenant content delivery feature.</p> <p>Work in Progress</p> <p>This project is under active development. APIs, CRD schemas, and controller behavior may change without notice. It is not yet recommended for production use.</p>"},{"location":"#overview","title":"Overview","text":"<p>The operator manages <code>DistributionTenant</code> custom resources that map 1:1 to AWS CloudFront distribution tenants. It handles:</p> <ul> <li>Full lifecycle management -- Create, update, and delete distribution tenants via the AWS API</li> <li>Disable-before-delete -- Automatically disables tenants before deletion (required by AWS)</li> <li>ETag-based concurrency -- Uses optimistic concurrency control on every update to prevent conflicts</li> <li>Drift detection -- Three-way diff (spec vs observed generation vs AWS state) distinguishes user-initiated changes from external drift, with configurable policy</li> <li>Managed certificate lifecycle -- Tracks CloudFront-managed ACM certificates through validation, issuance, and automatic attachment</li> <li>Pre-flight validation -- Validates the resource name, certificate coverage, and required parameters against the parent distribution before calling AWS</li> <li>Error classification -- Distinguishes terminal errors (domain conflicts, permission issues) from retryable ones (throttling, network errors) with detailed AWS error messages</li> <li>DNS record management -- Automatically creates and cleans up Route53 CNAME records, with cross-account support via STS</li> <li>Status conditions -- Reports <code>Ready</code>, <code>Synced</code>, <code>CertificateReady</code>, and <code>DNSReady</code> conditions following Kubernetes conventions</li> <li>Prometheus metrics -- Exposes reconciliation duration, error counts, drift detections, and AWS API call latency</li> <li>Finalizer-based cleanup -- Ensures AWS resources are properly disabled and deleted before the K8s object is removed</li> </ul>"},{"location":"#roadmap","title":"Roadmap","text":"<p>Planned features:</p> <ol> <li>TenantSource controller -- Automatically discover and reconcile <code>DistributionTenant</code> resources from an external database (PostgreSQL or DynamoDB). The CRD is already defined (<code>TenantSource</code>); controller logic is not yet implemented. This enables SaaS platforms to manage tenants from their existing data store without manually creating Kubernetes resources.</li> <li>Webhook validation -- Admission webhooks for deeper validation at create/update time (e.g., cross-field consistency, DNS reachability checks).</li> <li>Multi-provider DNS -- Support for DNS providers beyond Route53 (e.g., Cloudflare, Azure DNS).</li> </ol>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Installation -- Set up the operator in your cluster</li> <li>Quickstart -- Create your first distribution tenant</li> <li>CRD Reference -- Full spec and status field documentation</li> <li>Architecture -- How the reconciliation loop works</li> </ul>"},{"location":"#disclaimer","title":"Disclaimer","text":"<p>This project is not affiliated with, endorsed by, or sponsored by Amazon Web Services (AWS). All AWS service names and trademarks are the property of Amazon.com, Inc. or its affiliates.</p>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#development-setup","title":"Development Setup","text":"<p>Clone the repository and ensure you have the prerequisites installed.</p> <pre><code>git clone https://github.com/dsp0x4/cloudfront-tenant-operator.git\ncd cloudfront-tenant-operator\n</code></pre>"},{"location":"contributing/#common-commands","title":"Common Commands","text":"<pre><code># Run unit tests (uses envtest: real K8s API server + etcd, mock AWS client)\nmake test\n\n# Run linter\nmake lint\n\n# Auto-fix lint issues\nmake lint-fix\n\n# Regenerate CRD manifests and DeepCopy methods after editing *_types.go\nmake manifests generate\n\n# Install CRDs\nmake install\n\n# Run the operator locally against your current kubeconfig\nmake run\n</code></pre>"},{"location":"contributing/#test-structure","title":"Test Structure","text":"<p>Tests use Ginkgo + Gomega (BDD style):</p> <ul> <li><code>internal/controller/distributiontenant_controller_test.go</code> -- Integration tests using envtest (real K8s API) with a mock AWS client.</li> <li><code>internal/controller/change_detection_test.go</code> -- Unit tests for the three-way diff and drift policy logic.</li> <li><code>internal/aws/errors_test.go</code> -- Unit tests for AWS error classification.</li> <li><code>test/e2e/e2e_test.go</code> -- End-to-end tests designed to run against an isolated Kind cluster.</li> </ul> <p>Warning</p> <p>The e2e tests require a dedicated Kind cluster. Do not run them against a real cluster.</p>"},{"location":"contributing/#after-editing-types","title":"After Editing Types","text":"<p>If you modify any <code>*_types.go</code> file or kubebuilder markers, always run:</p> <pre><code>make manifests generate\n</code></pre> <p>This regenerates:</p> <ul> <li><code>config/crd/bases/*.yaml</code> -- CRD manifests</li> <li><code>config/rbac/role.yaml</code> -- RBAC rules from <code>+kubebuilder:rbac</code> markers</li> <li><code>**/zz_generated.deepcopy.go</code> -- DeepCopy methods</li> </ul> <p>Do not edit these generated files manually.</p>"},{"location":"contributing/#code-style","title":"Code Style","text":"<ul> <li>Use <code>log := log.FromContext(ctx)</code> for structured logging.</li> <li>Keep reconciliation idempotent: safe to run multiple times.</li> <li>At most one K8s API write per reconcile loop (see ResourceVersion Safety).</li> <li>Use owner references for automatic garbage collection.</li> <li>Wrap errors with context: <code>fmt.Errorf(\"failed to X: %w\", err)</code>.</li> </ul>"},{"location":"architecture/drift-detection/","title":"Drift Detection","text":"<p>The operator uses a three-way diff to distinguish between user-initiated spec changes and external modifications to AWS resources.</p>"},{"location":"architecture/drift-detection/#how-it-works","title":"How It Works","text":"<p>The three-way diff compares three pieces of information:</p> <ol> <li><code>metadata.generation</code> -- Kubernetes increments this automatically whenever the spec changes.</li> <li><code>status.observedGeneration</code> -- The operator sets this to the current generation after every successful reconciliation.</li> <li>Spec vs AWS comparison -- A field-by-field comparison of the CRD spec against the live AWS state.</li> </ol> <p>The logic:</p> Generation Match? Spec Matches AWS? Result <code>generation == observedGeneration</code> Yes No change -- steady state <code>generation != observedGeneration</code> No Spec change -- user modified the CR <code>generation != observedGeneration</code> Yes No-op spec change -- user changed and reverted, or changed a field the operator doesn't track <code>generation == observedGeneration</code> No Drift -- something outside the operator modified AWS"},{"location":"architecture/drift-detection/#drift-policies","title":"Drift Policies","text":"<p>The <code>--drift-policy</code> flag controls how the operator responds when drift is detected:</p>"},{"location":"architecture/drift-detection/#enforce-default","title":"<code>enforce</code> (default)","text":"<p>The spec is the single source of truth. When drift is detected, the operator pushes the K8s spec to AWS, overwriting whatever was changed externally.</p> <ul> <li>Sets <code>Synced=False</code> with reason <code>DriftDetected</code> briefly during the update.</li> <li>After the update succeeds, sets <code>Synced=True</code>.</li> </ul>"},{"location":"architecture/drift-detection/#report","title":"<code>report</code>","text":"<p>The operator logs the drift and sets status conditions, but does not modify the AWS state.</p> <ul> <li>Sets <code>Synced=False</code> with reason <code>DriftDetected</code>.</li> <li>Emits a <code>DriftDetected</code> Kubernetes event.</li> <li>The drift persists until the user either updates the spec to match AWS or switches to <code>enforce</code>.</li> </ul>"},{"location":"architecture/drift-detection/#suspend","title":"<code>suspend</code>","text":"<p>The operator skips drift detection entirely. The AWS state is not compared to the spec.</p> <ul> <li>Sets <code>driftDetected: true</code> in the status as an acknowledgment.</li> <li>Does not degrade the <code>Synced</code> condition.</li> <li>Useful during planned maintenance windows when AWS resources are intentionally modified outside the operator.</li> </ul>"},{"location":"architecture/drift-detection/#what-fields-are-compared","title":"What Fields Are Compared","text":"<p>The spec-vs-AWS comparison covers:</p> <ul> <li><code>enabled</code> state</li> <li><code>distributionId</code></li> <li><code>connectionGroupId</code></li> <li>Domain list (order-independent)</li> <li>Parameters (by name and value)</li> <li>Customizations: Web ACL (action + ARN), certificate ARN, geo restrictions (type + locations, order-independent)</li> </ul>"},{"location":"architecture/managed-certificates/","title":"Managed Certificates","text":"<p>When a <code>managedCertificateRequest</code> is configured in the spec, CloudFront requests and manages an ACM certificate automatically. The operator tracks the certificate through its lifecycle and attaches it to the tenant when it is issued.</p>"},{"location":"architecture/managed-certificates/#lifecycle","title":"Lifecycle","text":"<pre><code>                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502  Create Tenant   \u2502\n                    \u2502  with MCR in     \u2502\n                    \u2502  spec            \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                             \u2502\n                             \u25bc\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502  pending-        \u2502  CertificateReady=False\n                    \u2502  validation      \u2502  reason=PendingValidation\n                    \u2502  (poll every     \u2502\n                    \u2502  30s)            \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                             \u2502 DNS validated\n                             \u25bc\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502  issued          \u2502  CertificateReady=False\n                    \u2502  (auto-attach    \u2502  reason=Attaching\n                    \u2502  triggered)      \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                             \u2502 ARN persisted to spec\n                             \u2502 Update pushed to AWS\n                             \u25bc\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502  attached        \u2502  CertificateReady=True\n                    \u2502  (all domains    \u2502  reason=Validated\n                    \u2502  active)         \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/managed-certificates/#auto-attachment","title":"Auto-Attachment","text":"<p>When the operator detects that a managed certificate has been issued (<code>status: issued</code>) but not all domains are active, it:</p> <ol> <li>Persists the certificate ARN to <code>spec.customizations.certificate.arn</code>.</li> <li>Returns immediately (one K8s API write per reconcile).</li> <li>The spec change bumps the generation and triggers a new reconcile.</li> <li>The three-way diff detects a spec change and pushes the update to AWS via the normal update path.</li> </ol> <p>This two-step approach avoids <code>resourceVersion</code> conflicts and reuses the existing update logic (including ETag handling and validation).</p> <p>Note</p> <p>The auto-attach runs even when the AWS tenant status is <code>InProgress</code>. The certificate can be issued while a previous deployment is still propagating, and the operator persists the ARN immediately rather than waiting.</p>"},{"location":"architecture/managed-certificates/#validation-token-host","title":"Validation Token Host","text":"<p>The <code>validationTokenHost</code> field controls how CloudFront validates domain ownership:</p> Value Requirement <code>cloudfront</code> The domain must already have a DNS CNAME pointing to CloudFront. Use this when the domain is already serving traffic through CloudFront. <code>self-hosted</code> You manage the validation token yourself. Use this for domains not yet pointed to CloudFront."},{"location":"architecture/managed-certificates/#failure-handling","title":"Failure Handling","text":"<p>If the certificate validation fails or times out, the operator sets <code>CertificateReady=False</code> with reason <code>CertificateFailed</code> and includes the failure status in the condition message (e.g., <code>validation-timed-out</code>, <code>revoked</code>, <code>failed</code>).</p> <p>The operator continues to poll in steady state (every 5 minutes), so if the underlying issue is resolved, the status will update on the next reconcile.</p>"},{"location":"architecture/overview/","title":"Architecture Overview","text":""},{"location":"architecture/overview/#project-structure","title":"Project Structure","text":"<pre><code>cmd/main.go                              # Entrypoint, wires AWS client + controller + flags\napi/v1alpha1/                            # CRD type definitions\ninternal/controller/\n  distributiontenant_controller.go       # Reconciliation logic (incl. DNS management)\n  change_detection.go                    # Three-way diff and drift policy\ninternal/aws/\n  client.go                              # CloudFrontClient, DNSClient, ACMClient interfaces\n  cloudfront.go                          # Real AWS CloudFront SDK implementation\n  route53.go                             # Real AWS Route53 SDK implementation (DNSClient)\n  acm.go                                 # Real AWS ACM SDK implementation (ACMClient)\n  errors.go                              # Error classification (terminal vs retryable)\n  mock.go                                # Mock clients for testing\ninternal/metrics/\n  metrics.go                             # Prometheus metric definitions\n  tenant_collector.go                    # prometheus.Collector for tenant counts\n</code></pre>"},{"location":"architecture/overview/#reconciliation-flow","title":"Reconciliation Flow","text":"<p>The controller follows a multi-phase reconciliation loop:</p> <ol> <li>Create (DNS-first when configured):<ol> <li>Validate spec (name format, certificate coverage, required parameters).</li> <li>If DNS is configured and no managed cert: validate that the ACM certificate's SANs cover all tenant domains.</li> <li>Resolve CNAME target: the specified connection group's routing endpoint, or the account's default connection group endpoint if none is specified (multi-tenant distributions always route through a connection group).</li> <li>Upsert CNAME records in Route53 and store the change ID in status.</li> <li>Poll Route53 <code>GetChange</code> until the change reaches <code>INSYNC</code>.</li> <li>Call <code>CreateDistributionTenant</code>.</li> </ol> </li> <li>Poll: Requeue every 30 seconds until the AWS status transitions from <code>InProgress</code> to <code>Deployed</code>.</li> <li>Steady state: A three-way diff compares the spec, observed generation, and AWS state:<ul> <li>Spec change (generation bumped): validate, upsert DNS for current domains, push update to AWS, clean up orphaned DNS records on next steady-state cycle.</li> <li>Drift (generation matches, AWS differs): apply the configured drift policy.</li> <li>No change: update conditions, check managed cert lifecycle, clean up orphaned DNS records, requeue every 5 minutes.</li> </ul> </li> <li>Managed cert: Track <code>pending-validation</code> -&gt; <code>issued</code> -&gt; auto-attach ARN to spec -&gt; push update to AWS.</li> <li>Delete: Disable tenant -&gt; wait for <code>Deployed</code> -&gt; delete from AWS -&gt; delete DNS records from Route53 -&gt; remove finalizer.</li> </ol>"},{"location":"architecture/overview/#error-handling","title":"Error Handling","text":"<p>Errors from the AWS API are classified into categories that determine retry behavior:</p> Category Examples Behavior Terminal <code>CNAMEAlreadyExists</code>, <code>AccessDenied</code>, <code>InvalidArgument</code> Set condition, stop retrying, requeue after 5 min Domain validation pending <code>InvalidArgument</code> when <code>validationTokenHost=cloudfront</code> Set <code>DomainValidationPending</code> condition, retry every 5 min (see below) Terminal (DNS) <code>NoSuchHostedZone</code>, DNS <code>AccessDenied</code>, <code>InvalidChangeBatch</code>, <code>ConnectionGroupNotFound</code> Set DNSReady=False condition, stop retrying Terminal (Cert) Certificate SAN mismatch (domains not covered) Set Ready=False with <code>CertificateSANMismatch</code> reason Throttling <code>Throttling</code>, <code>TooManyRequests</code> Requeue with 60s backoff Throttling (DNS) Route53 <code>Throttling</code>, <code>PriorRequestNotComplete</code> Requeue with 60s backoff ETag mismatch <code>PreconditionFailed</code> Re-fetch and retry via rate limiter (no error metric) Retryable 5xx errors, network errors Return error for controller-runtime backoff Validation Name too short, missing certificate, missing parameters Set condition with specific message, requeue after 5 min <p>Domain validation pending: When <code>CreateDistributionTenant</code> fails with <code>InvalidArgument</code> and the tenant uses <code>managedCertificateRequest.validationTokenHost: \"cloudfront\"</code>, the error is treated as a transient DNS propagation delay instead of terminal. CloudFront requires the CNAME to be globally resolvable before it can serve the HTTP validation token, but Route53 <code>INSYNC</code> only guarantees authoritative nameserver updates -- global recursive resolver caches may lag by minutes to hours. This applies to both operator-managed DNS (<code>spec.dns</code> configured) and user-managed DNS. The operator sets <code>Ready=False</code> with reason <code>DomainValidationPending</code> and retries every 5 minutes until the create succeeds.</p> <p>All AWS errors preserve the original error message from the API response, so users see the exact reason for failure in the status conditions.</p>"},{"location":"architecture/overview/#resourceversion-safety","title":"ResourceVersion Safety","text":"<p>The controller ensures at most one Kubernetes API write (spec update or status update) per reconcile loop. This prevents <code>resourceVersion</code> conflicts that occur when the in-memory object becomes stale after a write.</p> <p>Operations that logically require multiple writes are split across reconcile cycles:</p> <ul> <li>Certificate attachment: Persists the certificate ARN to the spec (one write), then returns. The spec change triggers a watch event, and the next reconcile pushes the update to AWS.</li> <li>Deletion: Each step (disable, wait, delete, remove finalizer) is a separate reconcile with at most one write.</li> </ul>"},{"location":"architecture/overview/#dns-record-management","title":"DNS Record Management","text":"<p>When <code>spec.dns</code> is configured, the operator manages CNAME records in Route53 that point the tenant's domains to the CloudFront distribution or connection group endpoint.</p>"},{"location":"architecture/overview/#conditions","title":"Conditions","text":"Condition Status Reason Meaning <code>DNSReady</code> <code>True</code> <code>DNSReady</code> CNAME records are propagated in Route53 <code>DNSReady</code> <code>True</code> <code>DNSNotConfigured</code> <code>spec.dns</code> is not set; DNS is not managed <code>DNSReady</code> <code>False</code> <code>DNSRecordCreating</code> CNAME records were submitted to Route53 <code>DNSReady</code> <code>False</code> <code>DNSPropagating</code> Waiting for Route53 change to reach INSYNC <code>DNSReady</code> <code>False</code> <code>DNSError</code> A terminal DNS error occurred (check message) <code>Ready</code> <code>False</code> <code>CertificateSANMismatch</code> The ACM certificate's SANs don't cover the tenant's domains <code>Ready</code> <code>False</code> <code>DomainValidationPending</code> CloudFront cannot verify domain ownership yet (DNS propagation delay); retrying"},{"location":"architecture/overview/#cross-account-dns","title":"Cross-Account DNS","text":"<p>Use <code>spec.dns.assumeRoleArn</code> when the Route53 hosted zone is in a different AWS account. The operator uses STS <code>AssumeRole</code> to obtain temporary credentials for Route53 API calls only. CloudFront and ACM calls always use the operator's own credentials.</p>"},{"location":"architecture/overview/#required-iam-permissions","title":"Required IAM Permissions","text":"<p>The operator's IAM identity (or the assumed role for DNS) needs the following AWS permissions:</p> Permission Resource Used for <code>cloudfront:CreateDistributionTenant</code> <code>*</code> Creating tenants <code>cloudfront:GetDistributionTenant</code> <code>*</code> Reading tenant state <code>cloudfront:UpdateDistributionTenant</code> <code>*</code> Updating tenants <code>cloudfront:DeleteDistributionTenant</code> <code>*</code> Deleting tenants <code>cloudfront:GetDistribution</code> <code>*</code> Reading distribution config <code>cloudfront:GetManagedCertificateDetails</code> <code>*</code> Managed certificate lifecycle <code>cloudfront:GetConnectionGroup</code> <code>*</code> Resolving a connection group's routing endpoint <code>cloudfront:ListConnectionGroups</code> <code>*</code> Finding the default connection group's routing endpoint <code>acm:RequestCertificate</code> <code>*</code> Requesting managed ACM certificates <code>acm:DescribeCertificate</code> Certificate ARN Validating certificate SANs cover tenant domains <code>route53:ChangeResourceRecordSets</code> Hosted zone ARN Creating and deleting CNAME records (DNS only) <code>route53:GetChange</code> <code>*</code> Polling for record propagation (DNS only) <code>sts:AssumeRole</code> Role ARN from <code>assumeRoleArn</code> Cross-account Route53 access (only when configured)"},{"location":"architecture/overview/#cli-flags","title":"CLI Flags","text":"Flag Default Description <code>--metrics-bind-address</code> <code>0</code> Address the metrics endpoint binds to (<code>:8443</code> for HTTPS, <code>:8080</code> for HTTP, <code>0</code> to disable) <code>--health-probe-bind-address</code> <code>:8081</code> Address the health/ready probe endpoint binds to <code>--leader-elect</code> <code>false</code> Enable leader election (required for HA deployments) <code>--aws-region</code> (SDK default) AWS region for API calls; falls back to env vars / config file / IMDS <code>--drift-policy</code> <code>enforce</code> How to handle external drift: <code>enforce</code>, <code>report</code>, or <code>suspend</code> <code>--max-concurrent-reconciles</code> <code>1</code> Maximum number of concurrent reconcile loops <code>--metrics-secure</code> <code>true</code> Serve metrics over HTTPS (<code>false</code> for HTTP) <code>--metrics-cert-path</code> (empty) Directory containing TLS cert/key for the metrics server <code>--webhook-cert-path</code> (empty) Directory containing TLS cert/key for the webhook server <code>--enable-http2</code> <code>false</code> Enable HTTP/2 for metrics and webhook servers"},{"location":"architecture/overview/#prometheus-metrics","title":"Prometheus Metrics","text":""},{"location":"architecture/overview/#custom-metrics","title":"Custom metrics","text":"Metric Type Labels Description <code>cloudfront_tenant_operator_reconcile_errors_total</code> Counter <code>error_type</code> Incremented once per AWS API error classified by <code>handleAWSError</code>, <code>handleDNSError</code>, or <code>handleDomainValidationPending</code>. Label values: <code>error_type</code> is one of <code>domain_conflict</code>, <code>access_denied</code>, <code>invalid_spec</code>, <code>connection_group_not_found</code> (CloudFront terminal), <code>domain_validation_pending</code> (DNS propagation delay with cloudfront-hosted validation), <code>dns_zone_not_found</code>, <code>dns_access_denied</code>, <code>dns_invalid_input</code>, <code>dns_error</code> (DNS terminal), <code>throttling</code>, <code>dns_throttling</code> (rate limited), <code>retryable</code>, or <code>dns_retryable</code>. Not incremented for spec validation failures or Kubernetes API errors. <code>cloudfront_tenant_operator_tenants_total</code> Gauge <code>namespace</code>, <code>status</code> Current number of DistributionTenant resources per namespace. Implemented as a <code>prometheus.Collector</code> (kube-state-metrics / cert-manager pattern): the count is computed from the informer cache at Prometheus scrape time, not during reconciliation, so it is never stale and adds zero overhead to the reconcile loop. Label values: <code>status</code> is <code>Ready</code> (Ready condition is True) or <code>NotReady</code> (Ready condition is False or absent). <code>cloudfront_tenant_operator_drift_detected_total</code> Counter (none) Incremented once each time <code>handleDrift</code> fires, regardless of the configured drift policy (enforce, report, or suspend). Provides an aggregate signal for alerting on external AWS drift. Per-resource drift details are available via the <code>Synced</code> condition and <code>status.driftDetected</code> field. <code>cloudfront_tenant_operator_aws_api_call_duration_seconds</code> Histogram <code>operation</code> Wall-clock duration of each AWS SDK call. Recorded for both successful and failed calls. Label values: <code>operation</code> is one of <code>CreateDistributionTenant</code>, <code>GetDistributionTenant</code>, <code>UpdateDistributionTenant</code>, <code>DeleteDistributionTenant</code>, <code>GetDistribution</code>, <code>GetManagedCertificateDetails</code>, <code>GetConnectionGroup</code>, <code>ListConnectionGroups</code>, <code>Route53ChangeResourceRecordSets</code>, <code>Route53GetChange</code>, <code>ACMDescribeCertificate</code>."},{"location":"architecture/overview/#built-in-controller-runtime-metrics","title":"Built-in controller-runtime metrics","text":"<p>The following metrics are provided automatically by controller-runtime and cover reconcile duration, counts, and error totals per controller:</p> Metric Type Labels Description <code>controller_runtime_reconcile_total</code> Counter <code>controller</code>, <code>result</code> Total number of reconciliations. <code>result</code> is <code>success</code>, <code>error</code>, <code>requeue</code>, or <code>requeue_after</code>. <code>controller_runtime_reconcile_errors_total</code> Counter <code>controller</code> Total reconciliation errors (when <code>Reconcile</code> returns a non-nil error). <code>controller_runtime_reconcile_time_seconds</code> Histogram <code>controller</code> Wall-clock duration of each reconciliation loop. <code>controller_runtime_active_workers</code> Gauge <code>controller</code> Number of currently active reconcile workers."},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>kubectl v1.28+</li> <li>Access to a Kubernetes v1.28+ cluster</li> <li>AWS credentials with CloudFront permissions</li> <li>Helm 3.x (for Helm-based installation)</li> </ul> <p>For development, you additionally need:</p> <ul> <li>Go 1.25+</li> <li>Docker 17.03+</li> </ul>"},{"location":"getting-started/installation/#required-aws-iam-permissions","title":"Required AWS IAM Permissions","text":""},{"location":"getting-started/installation/#core-permissions-required","title":"Core permissions (required)","text":"<pre><code>{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"cloudfront:CreateDistributionTenant\",\n        \"cloudfront:GetDistributionTenant\",\n        \"cloudfront:UpdateDistributionTenant\",\n        \"cloudfront:DeleteDistributionTenant\",\n        \"cloudfront:GetDistribution\",\n        \"cloudfront:GetManagedCertificateDetails\",\n        \"cloudfront:GetConnectionGroup\",\n        \"cloudfront:ListConnectionGroups\"\n      ],\n      \"Resource\": \"*\"\n    },\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"acm:RequestCertificate\",\n        \"acm:DescribeCertificate\"\n      ],\n      \"Resource\": \"*\"\n    }\n  ]\n}\n</code></pre> Permission Used For <code>CreateDistributionTenant</code> Creating new tenants <code>GetDistributionTenant</code> Fetching current state for drift detection and status updates <code>UpdateDistributionTenant</code> Pushing spec changes and disabling before deletion <code>DeleteDistributionTenant</code> Removing tenants from AWS <code>GetDistribution</code> Pre-flight validation (certificate coverage, required parameters) <code>GetManagedCertificateDetails</code> Tracking managed certificate lifecycle <code>GetConnectionGroup</code> Resolving a connection group's routing endpoint for DNS <code>ListConnectionGroups</code> Finding the default connection group's routing endpoint <code>acm:RequestCertificate</code> Requesting managed ACM certificates via <code>managedCertificateRequest</code> <code>acm:DescribeCertificate</code> Validating certificate SANs cover tenant domains"},{"location":"getting-started/installation/#dns-management-permissions-optional","title":"DNS management permissions (optional)","text":"<p>Required only if you configure <code>spec.dns</code> on your tenants:</p> <pre><code>{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"route53:ChangeResourceRecordSets\",\n        \"route53:GetChange\"\n      ],\n      \"Resource\": \"*\"\n    }\n  ]\n}\n</code></pre> <p>If you use <code>spec.dns.assumeRoleArn</code> for cross-account DNS, the operator also needs <code>sts:AssumeRole</code> on the target role.</p>"},{"location":"getting-started/installation/#install-with-helm-recommended","title":"Install with Helm (Recommended)","text":"<p>The chart is published as an OCI artifact. CRDs are bundled in the chart's <code>crds/</code> directory and are automatically installed on first <code>helm install</code>.</p>"},{"location":"getting-started/installation/#install-from-oci-registry","title":"Install from OCI registry","text":"<pre><code>helm install cloudfront-tenant-operator \\\n  oci://ghcr.io/dsp0x4/charts/cloudfront-tenant-operator \\\n  --version &lt;version&gt; \\\n  --namespace cloudfront-tenant-operator-system \\\n  --create-namespace\n</code></pre>"},{"location":"getting-started/installation/#install-from-local-source","title":"Install from local source","text":"<p>If you cloned the repository, you can install directly from the chart directory:</p> <pre><code>helm install cloudfront-tenant-operator dist/chart/ \\\n  --namespace cloudfront-tenant-operator-system \\\n  --create-namespace\n</code></pre>"},{"location":"getting-started/installation/#configuration","title":"Configuration","text":"<p>Override defaults via <code>--set</code> or a custom values file:</p> <pre><code>helm install cloudfront-tenant-operator \\\n  oci://ghcr.io/dsp0x4/charts/cloudfront-tenant-operator \\\n  --version &lt;version&gt; \\\n  --namespace cloudfront-tenant-operator-system \\\n  --create-namespace \\\n  --set aws.region=us-east-1 \\\n  --set controller.driftPolicy=report \\\n  --set controller.maxConcurrentReconciles=3\n</code></pre> <p>Or with a values file:</p> <pre><code>helm install cloudfront-tenant-operator \\\n  oci://ghcr.io/dsp0x4/charts/cloudfront-tenant-operator \\\n  --version &lt;version&gt; \\\n  --namespace cloudfront-tenant-operator-system \\\n  --create-namespace \\\n  -f my-values.yaml\n</code></pre> <p>See <code>dist/chart/values.yaml</code> for all available options.</p>"},{"location":"getting-started/installation/#upgrade","title":"Upgrade","text":"<p>Helm does not update CRDs on upgrade (by design, to prevent accidental data loss). When upgrading to a version with CRD changes, apply the CRDs manually before running <code>helm upgrade</code>.</p> <p>From OCI registry:</p> <pre><code># 1. Pull the chart to extract updated CRDs\nhelm pull oci://ghcr.io/dsp0x4/charts/cloudfront-tenant-operator \\\n  --version &lt;new-version&gt; --untar --untardir /tmp\n\n# 2. Apply updated CRDs\nkubectl apply -f /tmp/cloudfront-tenant-operator/crds/\n\n# 3. Upgrade the operator\nhelm upgrade cloudfront-tenant-operator \\\n  oci://ghcr.io/dsp0x4/charts/cloudfront-tenant-operator \\\n  --version &lt;new-version&gt; \\\n  --namespace cloudfront-tenant-operator-system\n</code></pre> <p>From local source:</p> <pre><code># 1. Apply updated CRDs\nkubectl apply -f dist/chart/crds/\n\n# 2. Upgrade the operator\nhelm upgrade cloudfront-tenant-operator dist/chart/ \\\n  --namespace cloudfront-tenant-operator-system\n</code></pre>"},{"location":"getting-started/installation/#uninstall","title":"Uninstall","text":"<pre><code># Remove the operator (CRDs and CRs are preserved)\nhelm uninstall cloudfront-tenant-operator \\\n  --namespace cloudfront-tenant-operator-system\n\n# If you also want to remove CRDs (this deletes ALL DistributionTenant resources):\nkubectl delete -f dist/chart/crds/\n</code></pre>"},{"location":"getting-started/installation/#install-with-kustomize","title":"Install with Kustomize","text":""},{"location":"getting-started/installation/#install-crds","title":"Install CRDs","text":"<pre><code>make install\n</code></pre>"},{"location":"getting-started/installation/#deploy-the-operator","title":"Deploy the operator","text":"<pre><code>make deploy IMG=ghcr.io/dsp0x4/cloudfront-tenant-operator:&lt;version&gt;\n</code></pre>"},{"location":"getting-started/installation/#uninstall_1","title":"Uninstall","text":"<pre><code>kubectl delete -k config/samples/    # Delete CRs\nmake undeploy                        # Remove operator\nmake uninstall                       # Delete CRDs\n</code></pre>"},{"location":"getting-started/installation/#run-locally-development","title":"Run Locally (Development)","text":"<pre><code># Uses your local AWS credentials and kubeconfig\nmake run\n</code></pre>"},{"location":"getting-started/installation/#configure-aws-credentials","title":"Configure AWS Credentials","text":"<p>The operator pod needs AWS credentials to call the CloudFront and Route53 APIs. On EKS, use one of the native IAM integration methods below. On non-EKS clusters, fall back to environment variables or mounted secrets.</p>"},{"location":"getting-started/installation/#eks-pod-identity-recommended","title":"EKS Pod Identity (recommended)","text":"<p>EKS Pod Identity is the recommended approach. It requires no service account annotations and works at the cluster level.</p> <p>1. Install the Pod Identity Agent add-on (one-time per cluster):</p> <pre><code>aws eks create-addon \\\n  --cluster-name &lt;cluster&gt; \\\n  --addon-name eks-pod-identity-agent\n</code></pre> <p>2. Create an IAM role with a trust policy for Pod Identity:</p> <pre><code>{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": { \"Service\": \"pods.eks.amazonaws.com\" },\n      \"Action\": [\"sts:AssumeRole\", \"sts:TagSession\"]\n    }\n  ]\n}\n</code></pre> <p>Attach the required IAM permissions to this role.</p> <p>3. Create the Pod Identity association:</p> <pre><code>aws eks create-pod-identity-association \\\n  --cluster-name &lt;cluster&gt; \\\n  --namespace cloudfront-tenant-operator-system \\\n  --service-account &lt;service-account-name&gt; \\\n  --role-arn arn:aws:iam::123456789012:role/my-operator-role\n</code></pre> <p>Replace <code>&lt;service-account-name&gt;</code> with the service account created by the Helm chart (defaults to the release name).</p> <p>No Helm value changes are needed -- the Pod Identity Agent injects credentials automatically.</p>"},{"location":"getting-started/installation/#iam-roles-for-service-accounts-irsa","title":"IAM Roles for Service Accounts (IRSA)","text":"<p>IRSA works by annotating the service account with an IAM role ARN. It requires an OIDC provider configured on the cluster.</p> <p>With Helm:</p> <pre><code>helm install cloudfront-tenant-operator dist/chart/ \\\n  --namespace cloudfront-tenant-operator-system \\\n  --create-namespace \\\n  --set serviceAccount.annotations.\"eks\\.amazonaws\\.com/role-arn\"=arn:aws:iam::123456789012:role/my-operator-role\n</code></pre>"},{"location":"getting-started/installation/#static-credentials-non-eks-not-recommended","title":"Static credentials (non-EKS, not recommended)","text":"<p>Warning: Static credentials do not rotate automatically and increase the risk of credential leakage. Prefer Pod Identity or IRSA whenever possible. Use this method only on non-EKS clusters where no better alternative is available.</p> <p>For non-EKS clusters, inject AWS credentials via environment variables using the <code>extraEnv</code> chart value:</p> <pre><code>extraEnv:\n  - name: AWS_ACCESS_KEY_ID\n    valueFrom:\n      secretKeyRef:\n        name: aws-credentials\n        key: access-key-id\n  - name: AWS_SECRET_ACCESS_KEY\n    valueFrom:\n      secretKeyRef:\n        name: aws-credentials\n        key: secret-access-key\n  - name: AWS_REGION\n    value: us-east-1\n</code></pre>"},{"location":"getting-started/quickstart/","title":"Quickstart","text":"<p>This guide walks you through creating your first CloudFront distribution tenant.</p>"},{"location":"getting-started/quickstart/#prerequisites","title":"Prerequisites","text":"<p>Make sure you have installed the operator and have a multi-tenant CloudFront distribution ready.</p>"},{"location":"getting-started/quickstart/#create-a-distribution-tenant","title":"Create a Distribution Tenant","text":"<p>The Kubernetes resource name (<code>metadata.name</code>) is used as the CloudFront tenant name. It must be 3-128 characters, start and end with a lowercase alphanumeric, and contain only lowercase alphanumerics, dots, and hyphens.</p>"},{"location":"getting-started/quickstart/#minimal-example","title":"Minimal Example","text":"<p>Note: This minimal example does not specify a certificate. It only works if the domain is already covered by the default certificate of the parent distribution. Otherwise, add a <code>customizations.certificate</code> or a <code>managedCertificateRequest</code> to the spec.</p> <pre><code>apiVersion: cloudfront-tenant-operator.io/v1alpha1\nkind: DistributionTenant\nmetadata:\n  name: my-tenant-minimal\nspec:\n  distributionId: \"E1XNX8R2GOAABC\"\n  domains:\n    - domain: \"minimal.example.com\"\n</code></pre> <p>Apply the minimal sample:</p> <pre><code>kubectl apply -f config/samples/cloudfront_v1alpha1_distributiontenant.yaml\n</code></pre>"},{"location":"getting-started/quickstart/#full-example","title":"Full Example","text":"<p>The full example shows all available spec fields. See <code>config/samples/cloudfront_v1alpha1_distributiontenant_full.yaml</code>:</p> <pre><code>apiVersion: cloudfront-tenant-operator.io/v1alpha1\nkind: DistributionTenant\nmetadata:\n  name: my-tenant-full\nspec:\n  distributionId: \"E1XNX8R2GOAABC\"\n  domains:\n    - domain: \"full.example.com\"\n    - domain: \"www.full.example.com\"\n\n  enabled: true\n  connectionGroupId: \"cg_2whCJoXMYCjHcxaLGrkllvyABC\"\n\n  parameters:\n    - name: \"tenantName\"\n      value: \"full-tenant\"\n    - name: \"originPath\"\n      value: \"/tenants/full\"\n\n  customizations:\n    webAcl:\n      action: \"override\"\n      arn: \"arn:aws:wafv2:us-east-1:123456789012:global/webacl/my-tenant-waf/abc123\"\n    certificate:\n      arn: \"arn:aws:acm:us-east-1:123456789012:certificate/abc12345-1234-1234-1234-abc123456789\"\n    geoRestrictions:\n      restrictionType: \"whitelist\"\n      locations: [\"US\", \"CA\", \"GB\", \"DE\", \"FR\"]\n\n  tags:\n    - key: \"env\"\n      value: \"production\"\n    - key: \"team\"\n      value: \"platform\"\n</code></pre> <p>Additional samples are available for DNS management and managed certificates.</p>"},{"location":"getting-started/quickstart/#monitor-status","title":"Monitor Status","text":"<pre><code># Watch tenant status\nkubectl get distributiontenants -w\n\n# Detailed status\nkubectl describe distributiontenant my-tenant\n</code></pre> <p>The <code>STATUS</code> column shows the AWS deployment state, and the <code>READY</code> and <code>SYNCED</code> columns show the Kubernetes conditions:</p> <pre><code>NAME        STATUS      READY   SYNCED   ID                    AGE\nmy-tenant   InProgress  False   True     dt-abc123def456       10s\nmy-tenant   Deployed    True    True     dt-abc123def456       45s\n</code></pre>"},{"location":"getting-started/quickstart/#update-a-tenant","title":"Update a Tenant","text":"<p>Edit the spec and re-apply. The operator detects the change via a three-way diff and pushes the update to AWS:</p> <pre><code>kubectl edit distributiontenant my-tenant\n</code></pre>"},{"location":"getting-started/quickstart/#delete-a-tenant","title":"Delete a Tenant","text":"<pre><code>kubectl delete distributiontenant my-tenant\n</code></pre> <p>The operator will automatically disable the tenant, wait for the disable to propagate, then delete the AWS resource and remove the finalizer.</p>"},{"location":"reference/conditions/","title":"Conditions &amp; Reasons","text":"<p>The operator sets standard Kubernetes conditions on the <code>DistributionTenant</code> status to communicate the resource's state.</p>"},{"location":"reference/conditions/#condition-types","title":"Condition Types","text":""},{"location":"reference/conditions/#ready","title":"Ready","text":"<p>Indicates whether the tenant is fully deployed and serving traffic.</p> Status Reason Meaning <code>True</code> <code>Deployed</code> Tenant is deployed and serving traffic <code>False</code> <code>Creating</code> AWS resource creation is in progress <code>False</code> <code>Deploying</code> AWS deployment is in progress (after create or update) <code>False</code> <code>Disabling</code> Tenant is being disabled before deletion <code>False</code> <code>Deleting</code> Waiting for deployment to complete before deletion <code>False</code> <code>DomainConflict</code> Domain is already used by another distribution (terminal) <code>False</code> <code>AccessDenied</code> Insufficient IAM permissions (terminal) <code>False</code> <code>InvalidSpec</code> AWS rejected the request as invalid (terminal) <code>False</code> <code>AWSError</code> Other AWS API error (terminal) <code>False</code> <code>ValidationFailed</code> Spec failed pre-flight validation"},{"location":"reference/conditions/#synced","title":"Synced","text":"<p>Indicates whether the K8s spec matches the AWS state.</p> Status Reason Meaning <code>True</code> <code>InSync</code> Spec is in sync with AWS <code>False</code> <code>DriftDetected</code> AWS state was modified outside the operator <code>False</code> <code>UpdatePending</code> A spec change has been submitted but not yet deployed"},{"location":"reference/conditions/#certificateready","title":"CertificateReady","text":"<p>Indicates the status of a CloudFront-managed ACM certificate. Only set when <code>managedCertificateRequest</code> is configured in the spec.</p> Status Reason Meaning <code>True</code> <code>Validated</code> Certificate is validated and attached to the tenant <code>False</code> <code>PendingValidation</code> Certificate is awaiting DNS validation <code>False</code> <code>Attaching</code> Certificate has been issued but is being attached to the tenant <code>False</code> <code>CertificateFailed</code> Certificate validation failed or timed out <code>False</code> <code>NotConfigured</code> No managed certificate request is configured"},{"location":"reference/conditions/#dnsready","title":"DNSReady","text":"<p>Indicates whether DNS records have been created and propagated in Route53. Only relevant when <code>spec.dns</code> is configured.</p> Status Reason Meaning <code>True</code> <code>DNSReady</code> CNAME records are propagated in Route53 <code>True</code> <code>DNSNotConfigured</code> <code>spec.dns</code> is not set; DNS is not managed by the operator <code>False</code> <code>DNSRecordCreating</code> CNAME records were submitted to Route53 <code>False</code> <code>DNSPropagating</code> Waiting for Route53 change to reach INSYNC <code>False</code> <code>DNSError</code> A terminal DNS error occurred (check condition message)"},{"location":"reference/conditions/#additional-ready-reasons","title":"Additional Ready Reasons","text":"<p>These reasons are set on the <code>Ready</code> condition in specific scenarios:</p> Status Reason Meaning <code>False</code> <code>CertificateSANMismatch</code> The ACM certificate's SANs don't cover the tenant's domains <code>False</code> <code>DomainValidationPending</code> CloudFront cannot verify domain ownership yet (DNS propagation delay); retries every 5 minutes <code>False</code> <code>MissingParameters</code> Required distribution parameters are missing from the spec <code>False</code> <code>MissingCertificate</code> No certificate configured for a distribution that requires one"},{"location":"reference/controller-flags/","title":"Controller Flags","text":"<p>The controller manager accepts the following command-line flags.</p>"},{"location":"reference/controller-flags/#operator-specific-flags","title":"Operator-Specific Flags","text":"Flag Default Description <code>--drift-policy</code> <code>enforce</code> How to handle external drift on AWS resources. See Drift Detection for details. <code>--aws-region</code> (SDK default) AWS region for CloudFront API calls. If not set, uses AWS SDK default resolution (environment variables, config file, IMDS). <code>--max-concurrent-reconciles</code> <code>1</code> Maximum number of concurrent reconcile loops. Higher values improve throughput when managing many tenants but increase AWS API usage."},{"location":"reference/controller-flags/#drift-policy-values","title":"Drift Policy Values","text":"Value Behavior <code>enforce</code> Overwrite the AWS state with the K8s spec. The spec is treated as the single source of truth. <code>report</code> Log the drift and set status conditions, but do not modify the AWS state. <code>suspend</code> Skip drift detection entirely. Useful during planned maintenance windows when AWS resources are modified manually."},{"location":"reference/controller-flags/#infrastructure-flags","title":"Infrastructure Flags","text":"Flag Default Description <code>--metrics-bind-address</code> <code>0</code> Address for the metrics endpoint. Use <code>:8443</code> for HTTPS or <code>:8080</code> for HTTP. <code>0</code> disables metrics. <code>--health-probe-bind-address</code> <code>:8081</code> Address for health and readiness probes. <code>--leader-elect</code> <code>false</code> Enable leader election for controller manager. Required for HA deployments with multiple replicas. <code>--metrics-secure</code> <code>true</code> Serve the metrics endpoint over HTTPS. Set to <code>false</code> for HTTP. <code>--enable-http2</code> <code>false</code> Enable HTTP/2 for metrics and webhook servers."},{"location":"reference/controller-flags/#tls-certificate-flags","title":"TLS Certificate Flags","text":"<p>These flags are used to provide custom TLS certificates instead of the auto-generated self-signed ones. Only needed in production when using cert-manager or another certificate provider.</p> Flag Default Description <code>--metrics-cert-path</code> (empty) Directory containing the metrics server TLS certificate and key. <code>--metrics-cert-name</code> <code>tls.crt</code> Filename of the metrics server certificate within the cert directory. <code>--metrics-cert-key</code> <code>tls.key</code> Filename of the metrics server private key within the cert directory. <code>--webhook-cert-path</code> (empty) Directory containing the webhook server TLS certificate and key. <code>--webhook-cert-name</code> <code>tls.crt</code> Filename of the webhook server certificate within the cert directory. <code>--webhook-cert-key</code> <code>tls.key</code> Filename of the webhook server private key within the cert directory."},{"location":"reference/crd/","title":"CRD Specification","text":"<p>Full reference for the <code>DistributionTenant</code> custom resource.</p> <p>See the Go type definitions and example CRs for additional detail.</p>"},{"location":"reference/crd/#spec-fields","title":"Spec Fields","text":"Field Type Required Description <code>distributionId</code> string Yes ID of the parent multi-tenant distribution <code>domains</code> array of <code>DomainSpec</code> Yes List of domains to associate (min 1) <code>enabled</code> bool No Whether to serve traffic (default: <code>true</code>) <code>connectionGroupId</code> string No Connection group ID <code>parameters</code> array of <code>Parameter</code> No Key-value parameters for the distribution template <code>customizations</code> <code>Customizations</code> No WAF, certificate, and geo restriction overrides <code>managedCertificateRequest</code> <code>ManagedCertificateRequest</code> No CloudFront-managed ACM certificate configuration <code>tags</code> array of <code>Tag</code> No AWS resource tags <code>dns</code> <code>DNSConfig</code> No DNS record management config (see below)"},{"location":"reference/crd/#domainspec","title":"DomainSpec","text":"Field Type Required Description <code>domain</code> string Yes Fully qualified domain name"},{"location":"reference/crd/#parameter","title":"Parameter","text":"Field Type Required Description <code>name</code> string Yes Parameter name (must match a parameter defined in the distribution) <code>value</code> string Yes Parameter value"},{"location":"reference/crd/#customizations","title":"Customizations","text":"Field Type Required Description <code>webAcl</code> <code>WebAclCustomization</code> No WAF Web ACL override <code>certificate</code> <code>CertificateCustomization</code> No ACM certificate override <code>geoRestrictions</code> <code>GeoRestrictionCustomization</code> No Geographic restriction override <p>Note: ACM certificates used with CloudFront must be created in the us-east-1 region. This is an AWS requirement.</p>"},{"location":"reference/crd/#managedcertificaterequest","title":"ManagedCertificateRequest","text":"Field Type Required Description <code>validationTokenHost</code> string Yes Validation method: <code>\"cloudfront\"</code> or <code>\"self-hosted\"</code> <code>primaryDomainName</code> string Yes Primary domain for the certificate (must be one of the <code>spec.domains</code>) <code>certificateTransparencyLoggingPreference</code> string No <code>\"enabled\"</code> or <code>\"disabled\"</code>"},{"location":"reference/crd/#dnsconfig","title":"DNSConfig","text":"Field Type Required Description <code>provider</code> string Yes DNS provider (<code>\"route53\"</code>) <code>hostedZoneId</code> string No Route53 hosted zone ID where records will be managed <code>ttl</code> int64 No TTL for CNAME records in seconds (60-172800, default: <code>300</code>) <code>assumeRoleArn</code> string No IAM role ARN to assume for Route53 calls (cross-account DNS)"},{"location":"reference/crd/#status-fields","title":"Status Fields","text":"Field Type Description <code>id</code> string AWS-assigned distribution tenant ID <code>arn</code> string Amazon Resource Name <code>eTag</code> string Version identifier for optimistic concurrency <code>distributionTenantStatus</code> string AWS deployment status (<code>InProgress</code>, <code>Deployed</code>) <code>observedGeneration</code> int64 Last generation successfully reconciled (used for drift detection) <code>createdTime</code> timestamp When the distribution tenant was created in AWS <code>lastModifiedTime</code> timestamp When the distribution tenant was last modified in AWS <code>certificateArn</code> string ARN of the associated ACM certificate <code>managedCertificateStatus</code> string Managed cert lifecycle status (see values below) <code>driftDetected</code> bool Whether external drift was detected <code>lastDriftCheckTime</code> timestamp Timestamp of the last drift check <code>dnsChangeId</code> string Route53 change ID for a pending DNS record change <code>dnsTarget</code> string CNAME target (CloudFront endpoint) used for DNS records <code>domainResults</code> array of <code>DomainResult</code> Per-domain status from AWS <code>conditions</code> array of <code>Condition</code> Standard Kubernetes conditions"},{"location":"reference/crd/#managedcertificatestatus-values","title":"managedCertificateStatus Values","text":"Value Meaning <code>pending-validation</code> Certificate is awaiting DNS validation <code>issued</code> Certificate is validated and issued <code>inactive</code> Certificate is inactive <code>expired</code> Certificate has expired <code>validation-timed-out</code> DNS validation timed out <code>revoked</code> Certificate was revoked <code>failed</code> Certificate issuance failed"},{"location":"reference/crd/#domainresult","title":"DomainResult","text":"Field Type Description <code>domain</code> string Fully qualified domain name <code>status</code> string AWS-reported domain status (<code>active</code> or <code>inactive</code>)"},{"location":"reference/crd/#naming-constraints","title":"Naming Constraints","text":"<p>The Kubernetes resource name (<code>metadata.name</code>) is used as the CloudFront tenant name in AWS. It must satisfy both Kubernetes naming rules and CloudFront's constraints:</p> <ul> <li>3-128 characters</li> <li>Start and end with a lowercase alphanumeric character</li> <li>Contain only lowercase alphanumerics, dots (<code>.</code>), and hyphens (<code>-</code>)</li> </ul>"}]}